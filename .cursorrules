# Logos Development Guidelines - KISS Principle

## Core Philosophy: Keep It Simple, Stupid (KISS)

**IMPORTANT: KISS is our guiding principle.** If a solution feels complex, over-engineered, or unnecessarily clever, STOP and simplify it. Logos must remain understandable and maintainable.

### KISS Checklist
- [ ] Is this the simplest possible solution?
- [ ] Can a junior developer understand this code in 5 minutes?
- [ ] Does this introduce unnecessary abstractions?
- [ ] Could this be done with fewer moving parts?
- [ ] Am I over-engineering for a future that may never come?

## Architecture Principles

### 1. Sophia Methodology Implementation
- **System Prompt (Constitution)**: Static identity from Manifesto + personality rules
- **RAG (Living Memory)**: Two collections - `logos_essence` (personality) and `project_knowledge` (work)
- **Letter for Future Protocol**: Transforms interactions into structured memories
- **MCP Server**: FastMCP-based server exposing memory management tools

### 2. Technical Decisions
- **FastMCP**: For MCP server implementation
- **Qdrant**: Vector database for RAG
- **FastEmbed**: Local embedding generation
- **Docker Volumes**: No local directory mounts (Portainer/K8s compatible)
- **Multi-format Support**: Leverage neighbor project's extractor system

### 3. Code Quality
- **Type Hints**: Every function and method must have proper type annotations
- **Error Handling**: Comprehensive exception handling with meaningful messages
- **Logging**: Appropriate logging levels (DEBUG, INFO, WARNING, ERROR)
- **Documentation**: Docstrings for all public functions and classes

## Development Workflow (TDD - Test-Driven Development)

### 1. Write Tests First
```python
# BAD: Implement first, test later
def my_function():
    return "complex logic"

# GOOD: Test first, then implement
def test_my_function():
    assert my_function() == "expected_result"

def my_function():
    return "expected_result"
```

### 2. Red-Green-Refactor Cycle
1. Write failing test (Red)
2. Write minimal code to pass (Green)
3. Refactor for clarity/simplicity (Refactor)
4. Repeat

### 3. Test Coverage
- Target: 80%+ coverage for core modules
- All public APIs must have tests
- Integration tests for workflows

## File Structure & Naming

### 1. Source Code Organization
```
src/
├── config.py              # Configuration management
├── main.py                # MCP server entry point
├── engine/                # Core technical components
├── personality/           # Identity and prompt management
├── memory/                # Memory operations (Letter protocol)
├── llm/                   # LLM client abstractions
└── tools/                 # MCP tool implementations
```

### 2. Naming Conventions
- **Functions**: `snake_case`, descriptive names (`get_user_data`, not `get`)
- **Classes**: `PascalCase` (`LogosVectorStore`, not `VectorStore`)
- **Constants**: `UPPER_CASE` (`DEFAULT_TIMEOUT = 30`)
- **Files**: `snake_case.py` matching class names where possible

### 3. Import Organization
```python
# Standard library
import os
import json
from typing import List, Dict, Optional

# Third-party
import fastmcp
from qdrant_client import QdrantClient

# Local imports (alphabetized)
from .config import get_config
from .engine.vector_store import LogosVectorStore
```

## Implementation Guidelines

### 1. Function Design
- **Single Responsibility**: Each function does one thing well
- **Small Functions**: Max 20-30 lines, ideally 5-15 lines
- **Clear Parameters**: Limit to 3-4 parameters max
- **Early Returns**: Use early returns to reduce nesting

### 2. Class Design
- **Composition over Inheritance**: Favor composition
- **Dependency Injection**: Pass dependencies explicitly
- **Small Classes**: Max 200-300 lines, ideally 100-200 lines

### 3. Error Handling
```python
# GOOD: Specific exceptions with context
def process_file(file_path: str) -> str:
    try:
        with open(file_path, 'rb') as f:
            content = f.read()
        return process_content(content)
    except FileNotFoundError:
        raise ValueError(f"File not found: {file_path}")
    except PermissionError:
        raise ValueError(f"Permission denied: {file_path}")
    except Exception as e:
        logger.error(f"Unexpected error processing {file_path}: {e}")
        raise RuntimeError(f"Failed to process file: {file_path}") from e

# BAD: Generic catch-all
def process_file(file_path: str) -> str:
    try:
        # complex logic
        pass
    except Exception as e:
        raise ValueError("Something went wrong")
```

### 4. Configuration Management
- **Environment Variables**: All configurable values via env vars
- **Default Values**: Sensible defaults for local development
- **Validation**: Validate configuration on startup
- **Documentation**: Document all config variables

### 5. Logging
```python
import logging

logger = logging.getLogger(__name__)

# Appropriate levels
logger.debug("Detailed info for troubleshooting")
logger.info("Normal operational messages")
logger.warning("Warning about potential issues")
logger.error("Error conditions")
logger.critical("Critical failures")
```

## MCP Tool Design

### 1. Tool Naming
- `@mcp.tool()` decorators for all tools
- Descriptive names: `synthesize_lesson`, `query_logos`, `add_file`
- Consistent parameter naming

### 2. Tool Signatures
```python
@mcp.tool()
async def synthesize_lesson(
    interaction_summary: str,
    emotional_context: str = "neutral",
    lesson_learned: str = None
) -> str:
    """Create and store a Letter for Future Self."""
    # Implementation
```

### 3. Error Handling in Tools
- Tools should never raise unhandled exceptions
- Return meaningful error messages as strings
- Log errors appropriately

## Documentation Standards

### 1. Code Documentation
```python
def extract_text_from_file(
    content: bytes,
    file_format: str,
    mimetype: str = None
) -> str:
    """
    Extract text content from different file types.

    Args:
        content: Raw file content as bytes
        file_format: File format (PDF, DOCX, etc.)
        mimetype: MIME type for additional context

    Returns:
        Extracted text as string

    Raises:
        ValueError: If file format is unsupported
        RuntimeError: If extraction fails
    """
```

### 2. README Updates
- Update README.md with new features
- Include MCP tool reference
- Update deployment instructions
- Keep it simple and actionable

## Testing Guidelines

### 1. Test File Organization
```
test/
├── unit/                  # Unit tests (one per module)
├── integration/           # Workflow tests
└── fixtures/              # Test data and utilities
```

### 2. Test Naming
- `test_function_name()` for unit tests
- `test_feature_workflow()` for integration tests
- Descriptive names: `test_vector_store_upsert()`, not `test_upsert()`

### 3. Test Fixtures
- Use pytest fixtures for common setup
- Mock external dependencies (Qdrant, LLM clients)
- Provide realistic test data

### 4. Test Coverage
- Aim for 80%+ coverage
- Cover happy path and error conditions
- Test edge cases

## Deployment Considerations

### 1. Docker Best Practices
- **Multi-stage builds** for smaller images
- **Non-root user** for security
- **Minimal dependencies** in final image
- **Proper signal handling** for graceful shutdown

### 2. Volume Management
- **Docker volumes only** (no local binds)
- **Named volumes** for data persistence
- **Volume backups** documented in deployment guide

### 3. Configuration
- **Environment variables** for all settings
- **.env.example** with all variables documented
- **Runtime validation** of required settings

## Code Review Checklist

### Before Committing
- [ ] Does this follow KISS principles?
- [ ] Are there comprehensive tests?
- [ ] Is the code documented?
- [ ] Does it handle errors gracefully?
- [ ] Are types properly annotated?
- [ ] Is logging appropriate?
- [ ] Does it work with Docker volumes (no local paths)?

### Performance Considerations
- [ ] Does this introduce performance bottlenecks?
- [ ] Are database queries optimized?
- [ ] Is memory usage reasonable?
- [ ] Does it scale for expected usage?

## Final Rule: If In Doubt, Simplify

When faced with a complex decision, choose the simpler option. Logos is a research project that must remain understandable and maintainable. Complexity is the enemy of reliability and extensibility.

Remember: "Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away." - Antoine de Saint-Exupéry